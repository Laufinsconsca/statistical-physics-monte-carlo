import time
from os import makedirs
from os import path

import numpy as np
from check_n_is_integer import check_n_is_integer
from populate_cube import populate_cube
from play_out_conditions import play_out_conditions
from functions import plot
from correlation_function import calculate_correlation_function

if __name__ == '__main__':
    # МОДЕЛИРОВАНИЕ ПАРНОЙ КОРРЕЛЯЦИОННОЙ ФУНКЦИИ ДЛЯ АРГОНА В ЖИДКОМ СОСТОЯНИИ
    # Краткое описание:
    # Корреляционная функция показывает отношение концентрации на данном расстоянии к средней концентрации.
    # Около нуля функция равна нулю, так как частицы не могут близко подойти друг к другу.
    # При стремлении расстояния к бесконечности концентрация стремится к средней, поэтому отношение стремится к единице.
    #  --------------------------- <общие константы> -------------------------------------------------------------------
    k = 1.38e-23  # постоянная Больцмана, Дж/К
    #  --------------------------- </общие константы> ------------------------------------------------------------------
    #  --------------------------- <константы задачи> ------------------------------------------------------------------
    N = 4 ** 3  # число частиц в одной ячейке
    M = 50000  # количество разыгрываемых состояний
    r1 = 0.1  # начальный аргумент корреляционной функции
    h_r = 0.1  # шаг изменения аргумента корреляционной функции
    delta_r = 0.01  # толщина шарового слоя
    delta = 0.1  # константа рандомного сдвига
    M_relax = 1000  # отсеиваем первые 1000 состояний
    #  --------------------------- <параметры газа> --------------------------------------------------------------------
    temperature = 85  # температура газа, K
    mass = 39.948 * 1.660539e-27  # масса одной молекулы Ar, кг
    energy = 1.04e-2 * 1.6e-19  # характерная энергия задачи для Ar, Дж
    sigma = 3.4e-10  # Ar, м
    ro = 1401  # плотность жидкого Ar, кг/м^3
    #  --------------------------- </параметры газа> -------------------------------------------------------------------
    #  --------------------------- </константы задачи> -----------------------------------------------------------------
    #  --------------------------- <вычисляемые константы> -------------------------------------------------------------
    N_coord = check_n_is_integer(N ** (1. / 3))
    # количество частиц вдоль одной любой координаты (с проверкой на целочисленность)
    T0 = energy / k  # характерная температура задачи
    n_concentration = ro / mass  # концентрация
    # T = temperature / T0  # безразмерная температура
    T = np.linspace(temperature / T0, temperature / T0, 1)  # безразмерная температура
    a = sigma  # берём sigma за характерный параметр длины
    n = n_concentration * (a ** 3)  # безразмерная концентрация
    V = N / n  # безразмерный объём
    L0 = V ** (1. / 3)  # безразмерная длина ребра ячейки моделирования
    r2 = L0 / 2  # конечный аргумент корреляционной функции (расстояние от центра до вершины куба)
    L = L0 / N_coord  # безразмерная длина ребра ячейки моделирования, содержащей одну частицу
    r_number = (r2 - r1) / h_r  # количество разбиений интервала изменения аргумента корреляционной функции
    r = np.linspace(r1, r2, int(r_number))  # аргумент корреляционной функции
    # --------------------------- </вычисляемые константы> -------------------------------------------------------------
    # --------------------------- <вычисляем корреляционнную функцию> --------------------------------------------------
    corr_func = np.zeros((len(T), int(r_number)))
    for i in range(len(T)):
        print("Начат расчёт при T = " + str(T[i]))
        start_time = time.time()
        molecules_ensemble = np.zeros((M, N, 3))  # содержит положения всех частиц во всех состояниях
        molecules_ensemble[0] = populate_cube(N_coord, L)  # заполняем куб частицами (начальное расположение)
        #  --------------------------- <разыгрываем состояния> ---------------------------------------------------------
        molecules_ensemble = play_out_conditions(M, molecules_ensemble, N, delta, L0, T[i])
        print("Состояния разыграны")
        #  --------------------------- </разыгрываем состояния> --------------------------------------------------------
        corr_func[i] = calculate_correlation_function(r, M, molecules_ensemble, M_relax, delta_r, L0, n)
        end_time = time.time()
        #  --------------------------- <сохраняем массив с корреляционной функцией> ------------------------------------
        folder_name = "corr_func_arrays/M=" + str(M) + "/N=" + str(N)
        if not path.exists(folder_name):
            makedirs(folder_name)
        np.save(folder_name + "/corr_func M=" + str(M) + ", N=" + str(N) + ", T=" + str(T[i]), corr_func[i])
        #  --------------------------- </сохраняем массив с корреляционной функцией> -----------------------------------
        print(str(end_time - start_time))
        print("Расчёт при T* = " + str(T[i]) + " завершён")
    # --------------------------- </вычисляем корреляционнную функцию> -------------------------------------------------
    # --------------------------- <строим корреляционнную функцию> -----------------------------------------------------
    for i in range(len(T)):
        plot(r, corr_func[i], "g(r*), парная корреляционная функция при T = " + str(T[i]), "r*", "g(r*)")
    # --------------------------- </строим корреляционнную функцию> ----------------------------------------------------
